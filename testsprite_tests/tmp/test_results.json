[
  {
    "projectId": "5c818b43-5e36-4bc2-a2fa-87f6e50dd335",
    "testId": "bdf5fe9f-c7e8-44b9-b192-cd985c705f5b",
    "userId": "047854f8-5091-70b6-a288-9cd9577df3b3",
    "title": "TC001-test_jobseeker_resume_management",
    "description": "Verify that job seekers can create, update, retrieve, and delete multiple resumes correctly through the API, ensuring data persistence and ATS scan integration.",
    "code": "import requests\nimport copy\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\n# Assumed authentication: For test purposes, a job seeker user token is required.\n# Since no auth endpoint details nor token are provided, replace this with a valid JWT token string.\nJOBSEEKER_AUTH_TOKEN = \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.jobseeker_token_placeholder\"\n\n\ndef test_jobseeker_resume_management():\n    headers = {\n        \"Authorization\": JOBSEEKER_AUTH_TOKEN,\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n\n    created_resume_ids = []\n\n    try:\n        # Create two resumes\n        resume_data_1 = {\n            \"title\": \"Software Engineer Resume\",\n            \"summary\": \"Detail-oriented software engineer with 5 years of experience.\",\n            \"skills\": [\"Python\", \"Django\", \"REST API\", \"SQL\"],\n            \"experiences\": [\n                {\n                    \"company\": \"Tech Corp\",\n                    \"role\": \"Backend Developer\",\n                    \"start_date\": \"2020-01-01\",\n                    \"end_date\": \"2023-01-01\",\n                    \"description\": \"Developed APIs and backend services.\"\n                }\n            ],\n            \"education\": [\n                {\n                    \"institution\": \"State University\",\n                    \"degree\": \"BSc Computer Science\",\n                    \"start_date\": \"2015-09-01\",\n                    \"end_date\": \"2019-06-01\"\n                }\n            ]\n        }\n        resp_create_1 = requests.post(\n            f\"{BASE_URL}/api/jobseeker/resumes\",\n            json=resume_data_1,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert resp_create_1.status_code == 201\n        resume_1 = resp_create_1.json()\n        assert \"id\" in resume_1\n        created_resume_ids.append(resume_1[\"id\"])\n\n        resume_data_2 = {\n            \"title\": \"Data Scientist Resume\",\n            \"summary\": \"Experienced data scientist with a focus on machine learning.\",\n            \"skills\": [\"Python\", \"Pandas\", \"scikit-learn\", \"Data Visualization\"],\n            \"experiences\": [\n                {\n                    \"company\": \"Data Insights\",\n                    \"role\": \"Data Scientist\",\n                    \"start_date\": \"2019-07-01\",\n                    \"end_date\": \"2022-12-01\",\n                    \"description\": \"Created predictive models and data visualizations.\"\n                }\n            ],\n            \"education\": [\n                {\n                    \"institution\": \"Tech Institute\",\n                    \"degree\": \"MSc Data Science\",\n                    \"start_date\": \"2017-09-01\",\n                    \"end_date\": \"2019-06-01\"\n                }\n            ]\n        }\n        resp_create_2 = requests.post(\n            f\"{BASE_URL}/api/jobseeker/resumes\",\n            json=resume_data_2,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert resp_create_2.status_code == 201\n        resume_2 = resp_create_2.json()\n        assert \"id\" in resume_2\n        created_resume_ids.append(resume_2[\"id\"])\n\n        # Update the first resume - add a new skill and update summary\n        updated_resume_1 = copy.deepcopy(resume_data_1)\n        updated_resume_1[\"summary\"] = \"Senior software engineer with 6 years of experience.\"\n        updated_resume_1[\"skills\"].append(\"Docker\")\n\n        resp_update_1 = requests.put(\n            f\"{BASE_URL}/api/jobseeker/resumes/{resume_1['id']}\",\n            json=updated_resume_1,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert resp_update_1.status_code == 200\n        updated_resume_resp = resp_update_1.json()\n        assert updated_resume_resp.get(\"summary\") == updated_resume_1[\"summary\"]\n        assert \"Docker\" in updated_resume_resp.get(\"skills\", [])\n\n        # Retrieve and verify both resumes\n        for resume_id, original_data in zip(created_resume_ids, [updated_resume_1, resume_data_2]):\n            resp_get = requests.get(\n                f\"{BASE_URL}/api/jobseeker/resumes/{resume_id}\",\n                headers=headers,\n                timeout=TIMEOUT,\n            )\n            assert resp_get.status_code == 200\n            resume = resp_get.json()\n            # Basic verification of keys and content\n            assert resume[\"id\"] == resume_id\n            assert resume[\"title\"] == original_data[\"title\"]\n            ats_scan_val = resume.get(\"ats_scan\")\n            assert isinstance(ats_scan_val, (str, dict)) or ats_scan_val is None\n            # Confirm skills contain listed skills\n            for skill in original_data[\"skills\"]:\n                assert skill in resume.get(\"skills\", [])\n\n        # Run ATS scan on the second resume and verify response\n        resp_ats_scan = requests.post(\n            f\"{BASE_URL}/api/jobseeker/resumes/{resume_2['id']}/ats-scan\",\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert resp_ats_scan.status_code == 200\n        ats_scan_result = resp_ats_scan.json()\n        assert \"score\" in ats_scan_result and isinstance(ats_scan_result[\"score\"], (int, float))\n        assert \"feedback\" in ats_scan_result\n\n    finally:\n        # Clean up: delete created resumes\n        for resume_id in created_resume_ids:\n            try:\n                resp_delete = requests.delete(\n                    f\"{BASE_URL}/api/jobseeker/resumes/{resume_id}\",\n                    headers=headers,\n                    timeout=TIMEOUT,\n                )\n                # Accept 200 or 204 or 404 (if already deleted)\n                assert resp_delete.status_code in (200, 204, 404)\n            except Exception:\n                pass\n\n\ntest_jobseeker_resume_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 149, in <module>\n  File \"<string>\", line 51, in test_jobseeker_resume_management\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-09T13:27:22.654Z",
    "modified": "2025-10-09T13:31:34.573Z"
  },
  {
    "projectId": "5c818b43-5e36-4bc2-a2fa-87f6e50dd335",
    "testId": "6e78e66e-0012-4aef-8706-dff8b8e3ae57",
    "userId": "047854f8-5091-70b6-a288-9cd9577df3b3",
    "title": "TC002-test_recruiter_job_posting_and_applicant_ranking",
    "description": "Ensure recruiters can post new jobs, update existing listings, and view applicant lists with ATS-based auto-ranking accurately reflected in the database and UI.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\n# These credentials should be valid recruiter credentials in the system for testing\nRECRUITER_CREDENTIALS = {\n    \"email\": \"testrecruiter@example.com\",\n    \"password\": \"TestPassword123!\"\n}\n\ndef test_recruiter_job_posting_and_applicant_ranking():\n    headers = {\"Content-Type\": \"application/json\"}\n    session = requests.Session()\n    try:\n        # Step 1: Login as recruiter and get JWT token\n        login_resp = session.post(\n            f\"{BASE_URL}/api/auth/login\",\n            json=RECRUITER_CREDENTIALS,\n            timeout=TIMEOUT,\n            headers=headers\n        )\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        assert \"token\" in login_data, \"No token found in login response\"\n        token = login_data[\"token\"]\n        auth_headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n\n        # Step 2: Post a new job\n        new_job_payload = {\n            \"title\": \"Test Automation Engineer\",\n            \"description\": \"Responsible for creating automated tests.\",\n            \"location\": \"Remote\",\n            \"employment_type\": \"Full-time\",\n            \"salary_range\": {\"min\": 70000, \"max\": 90000},\n            \"requirements\": [\"Python\", \"Selenium\", \"API testing\"],\n            \"benefits\": [\"Health insurance\", \"401k matching\"]\n        }\n        post_job_resp = session.post(\n            f\"{BASE_URL}/api/recruiter/jobs\",\n            json=new_job_payload,\n            timeout=TIMEOUT,\n            headers=auth_headers\n        )\n        assert post_job_resp.status_code == 201, f\"Job posting failed with status {post_job_resp.status_code}\"\n        job_data = post_job_resp.json()\n        assert \"id\" in job_data, \"Job ID not returned after creation\"\n        job_id = job_data[\"id\"]\n\n        # Step 3: Update the existing job listing\n        update_job_payload = {\n            \"title\": \"Senior Test Automation Engineer\",\n            \"description\": \"Lead and develop automated test frameworks.\",\n            \"location\": \"Remote\",\n            \"employment_type\": \"Full-time\",\n            \"salary_range\": {\"min\": 85000, \"max\": 110000},\n            \"requirements\": [\"Python\", \"Selenium\", \"API testing\", \"Leadership\"],\n            \"benefits\": [\"Health insurance\", \"401k matching\", \"Remote work stipend\"]\n        }\n        update_resp = session.put(\n            f\"{BASE_URL}/api/recruiter/jobs/{job_id}\",\n            json=update_job_payload,\n            timeout=TIMEOUT,\n            headers=auth_headers\n        )\n        assert update_resp.status_code == 200, f\"Job update failed with status {update_resp.status_code}\"\n        updated_job = update_resp.json()\n        assert updated_job.get(\"title\") == update_job_payload[\"title\"], \"Job title not updated correctly\"\n        assert updated_job.get(\"salary_range\") == update_job_payload[\"salary_range\"], \"Salary range not updated\"\n\n        # Step 4: Retrieve applicant list for the job\n        applicants_resp = session.get(\n            f\"{BASE_URL}/api/recruiter/jobs/{job_id}/applicants\",\n            timeout=TIMEOUT,\n            headers=auth_headers\n        )\n        assert applicants_resp.status_code == 200, f\"Failed to get applicants list, status {applicants_resp.status_code}\"\n        applicants_data = applicants_resp.json()\n        assert isinstance(applicants_data, list), \"Applicants list response is not a list\"\n\n        # Validate ATS-based auto-ranking is present and correctly formatted for each applicant if any applicants exist\n        for applicant in applicants_data:\n            assert \"ats_score\" in applicant, \"ATS score missing for applicant\"\n            assert isinstance(applicant[\"ats_score\"], (int, float)), \"ATS score is not numeric\"\n            assert \"candidate_id\" in applicant, \"Candidate ID missing in applicant data\"\n            # Additional optional UI reflected checks can be included if UI data provided via API\n\n    finally:\n        # Cleanup: Delete the created job listing if job_id exists\n        try:\n            if 'job_id' in locals():\n                delete_resp = session.delete(\n                    f\"{BASE_URL}/api/recruiter/jobs/{job_id}\",\n                    timeout=TIMEOUT,\n                    headers=auth_headers\n                )\n                assert delete_resp.status_code in (200, 204), f\"Failed to delete job with status {delete_resp.status_code}\"\n        except Exception:\n            pass\n\ntest_recruiter_job_posting_and_applicant_ranking()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 101, in <module>\n  File \"<string>\", line 23, in test_recruiter_job_posting_and_applicant_ranking\nAssertionError: Login failed with status 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-09T13:27:22.660Z",
    "modified": "2025-10-09T13:29:05.217Z"
  },
  {
    "projectId": "5c818b43-5e36-4bc2-a2fa-87f6e50dd335",
    "testId": "77f91daf-9c8f-4a21-afc8-e0904e2beeba",
    "userId": "047854f8-5091-70b6-a288-9cd9577df3b3",
    "title": "TC003-test_admin_user_and_recruiter_management",
    "description": "Validate that admins can retrieve paginated lists of users and recruiters, perform suspension and verification actions, and manage duplicates effectively via the API.",
    "code": "import requests\nfrom requests.exceptions import RequestException\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\n# Admin credentials - assumed for test, replace with valid test admin credentials or environment variables\nADMIN_LOGIN_PAYLOAD = {\n    \"username\": \"admin_test_user\",\n    \"password\": \"admin_test_password\"\n}\n\ndef test_admin_user_and_recruiter_management():\n    session = requests.Session()\n    try:\n        # 1. Admin login to get JWT token and (if needed) 2FA\n        admin_auth_url = f\"{BASE_URL}/api/admin/auth/login\"\n        resp = session.post(admin_auth_url, json=ADMIN_LOGIN_PAYLOAD, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Admin login failed with status {resp.status_code}\"\n        auth_data = resp.json()\n        token = auth_data.get(\"token\")\n        assert token and isinstance(token, str), \"No JWT token received on admin login\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # 2. Retrieve paginated list of users\n        users_url = f\"{BASE_URL}/api/admin/users\"\n        params = {\"page\": 1, \"limit\": 10}\n        resp = session.get(users_url, headers=headers, params=params, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Failed to get users list, status {resp.status_code}\"\n        users_data = resp.json()\n        assert isinstance(users_data, dict), \"Users list response should be a dict\"\n        assert \"users\" in users_data and isinstance(users_data[\"users\"], list), \"Users list missing or invalid\"\n        assert \"total\" in users_data and isinstance(users_data[\"total\"], int), \"Total count missing or invalid\"\n        assert len(users_data[\"users\"]) <= params[\"limit\"]\n\n        # If no users, create one for tests (assuming admin can create users)\n        user_id = None\n        if users_data[\"users\"]:\n            user_id = users_data[\"users\"][0].get(\"id\")\n        else:\n            create_user_payload = {\n                \"username\": \"tempuser_test\",\n                \"email\": \"tempuser_test@example.com\",\n                \"role\": \"jobseeker\",\n                \"password\": \"TempPass123!\"\n            }\n            resp = session.post(f\"{BASE_URL}/api/admin/users\", json=create_user_payload, headers=headers, timeout=TIMEOUT)\n            assert resp.status_code == 201, f\"Failed to create user for testing, status {resp.status_code}\"\n            user_id = resp.json().get(\"id\")\n            assert user_id, \"No ID returned after user creation\"\n\n        # 3. Retrieve paginated list of recruiters\n        recruiters_url = f\"{BASE_URL}/api/admin/recruiters\"\n        params = {\"page\": 1, \"limit\": 10}\n        resp = session.get(recruiters_url, headers=headers, params=params, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Failed to get recruiters list, status {resp.status_code}\"\n        recruiters_data = resp.json()\n        assert isinstance(recruiters_data, dict), \"Recruiters list response should be a dict\"\n        assert \"recruiters\" in recruiters_data and isinstance(recruiters_data[\"recruiters\"], list), \"Recruiters list missing or invalid\"\n        assert \"total\" in recruiters_data and isinstance(recruiters_data[\"total\"], int), \"Total count missing or invalid\"\n        assert len(recruiters_data[\"recruiters\"]) <= params[\"limit\"]\n\n        # If no recruiters, create one for tests (assuming admin can create recruiters)\n        recruiter_id = None\n        if recruiters_data[\"recruiters\"]:\n            recruiter_id = recruiters_data[\"recruiters\"][0].get(\"id\")\n        else:\n            create_recruiter_payload = {\n                \"username\": \"temprecruiter_test\",\n                \"email\": \"temprecruiter_test@example.com\",\n                \"role\": \"recruiter\",\n                \"password\": \"TempPass123!\"\n            }\n            resp = session.post(f\"{BASE_URL}/api/admin/recruiters\", json=create_recruiter_payload, headers=headers, timeout=TIMEOUT)\n            assert resp.status_code == 201, f\"Failed to create recruiter for testing, status {resp.status_code}\"\n            recruiter_id = resp.json().get(\"id\")\n            assert recruiter_id, \"No ID returned after recruiter creation\"\n\n        # 4. Perform suspension on user\n        suspend_user_url = f\"{BASE_URL}/api/admin/users/{user_id}/suspend\"\n        suspend_payload = {\"suspend\": True}\n        resp = session.put(suspend_user_url, json=suspend_payload, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Failed to suspend user, status {resp.status_code}\"\n        suspend_resp = resp.json()\n        assert suspend_resp.get(\"suspended\") is True\n\n        # Unsuspend user to cleanup\n        suspend_payload = {\"suspend\": False}\n        resp = session.put(suspend_user_url, json=suspend_payload, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Failed to unsuspend user, status {resp.status_code}\"\n        suspend_resp = resp.json()\n        assert suspend_resp.get(\"suspended\") is False\n\n        # 5. Perform verification on recruiter\n        verify_recruiter_url = f\"{BASE_URL}/api/admin/recruiters/{recruiter_id}/verify\"\n        verify_payload = {\"verified\": True}\n        resp = session.put(verify_recruiter_url, json=verify_payload, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Failed to verify recruiter, status {resp.status_code}\"\n        verify_resp = resp.json()\n        assert verify_resp.get(\"verified\") is True\n\n        # Unverify recruiter to cleanup\n        verify_payload = {\"verified\": False}\n        resp = session.put(verify_recruiter_url, json=verify_payload, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Failed to unverify recruiter, status {resp.status_code}\"\n        verify_resp = resp.json()\n        assert verify_resp.get(\"verified\") is False\n\n        # 6. Manage duplicates - get list and try to merge or resolve\n        duplicates_url = f\"{BASE_URL}/api/admin/duplicates\"\n        resp = session.get(duplicates_url, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Failed to get duplicates list, status {resp.status_code}\"\n        duplicates_data = resp.json()\n        assert isinstance(duplicates_data, dict)\n        duplicates_list = duplicates_data.get(\"duplicates\", [])\n        assert isinstance(duplicates_list, list)\n\n        # If duplicates exist, attempt to resolve a duplicate (assuming API endpoint)\n        if duplicates_list:\n            duplicate = duplicates_list[0]\n            duplicate_id = duplicate.get(\"id\")\n            resolve_url = f\"{BASE_URL}/api/admin/duplicates/{duplicate_id}/resolve\"\n            resolve_payload = {\"action\": \"merge\"}\n            resp = session.post(resolve_url, json=resolve_payload, headers=headers, timeout=TIMEOUT)\n            assert resp.status_code == 200, f\"Failed to resolve duplicate, status {resp.status_code}\"\n            resolve_resp = resp.json()\n            assert resolve_resp.get(\"resolved\") is True\n\n    except RequestException as e:\n        assert False, f\"Request failed: {str(e)}\"\n    finally:\n        # Cleanup created user and recruiter if created during test\n        if 'user_id' in locals() and user_id:\n            try:\n                del_resp = session.delete(f\"{BASE_URL}/api/admin/users/{user_id}\", headers=headers, timeout=TIMEOUT)\n                assert del_resp.status_code in (200, 204), \"Failed to delete test user in cleanup\"\n            except Exception:\n                pass\n        if 'recruiter_id' in locals() and recruiter_id:\n            try:\n                del_resp = session.delete(f\"{BASE_URL}/api/admin/recruiters/{recruiter_id}\", headers=headers, timeout=TIMEOUT)\n                assert del_resp.status_code in (200, 204), \"Failed to delete test recruiter in cleanup\"\n            except Exception:\n                pass\n\ntest_admin_user_and_recruiter_management()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 150, in <module>\n  File \"<string>\", line 19, in test_admin_user_and_recruiter_management\nAssertionError: Admin login failed with status 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-09T13:27:22.666Z",
    "modified": "2025-10-09T13:29:17.437Z"
  },
  {
    "projectId": "5c818b43-5e36-4bc2-a2fa-87f6e50dd335",
    "testId": "c73bea06-af63-41cd-b56f-93d621621b38",
    "userId": "047854f8-5091-70b6-a288-9cd9577df3b3",
    "title": "TC004-test_authentication_with_role_based_access_and_2fa",
    "description": "Test the authentication endpoints for job seekers, recruiters, and admins, including JWT token issuance, role-based access control enforcement, and optional two-factor authentication for admins.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_authentication_with_role_based_access_and_2fa():\n    \"\"\"\n    Test the authentication endpoints for job seekers, recruiters, and admins,\n    including JWT token issuance, role-based access control enforcement,\n    and optional two-factor authentication for admins.\n    \"\"\"\n    # Sample users credentials (assuming these users exist or the system supports these test accounts)\n    jobseeker_credentials = {\n        \"email\": \"jobseeker@example.com\",\n        \"password\": \"JobSeekerPass123!\"\n    }\n    recruiter_credentials = {\n        \"email\": \"recruiter@example.com\",\n        \"password\": \"RecruiterPass123!\"\n    }\n    admin_credentials = {\n        \"email\": \"admin@example.com\",\n        \"password\": \"AdminPass123!\",\n        \"twoFactorCode\": \"123456\"  # Optional 2FA code for admin; can be empty or omitted to test no-2fa\n    }\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # 1. Jobseeker login\n    response_js = requests.post(\n        f\"{BASE_URL}/api/auth/login\",\n        json={\n            \"email\": jobseeker_credentials[\"email\"],\n            \"password\": jobseeker_credentials[\"password\"]\n        },\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    assert response_js.status_code == 200, \"Jobseeker login failed\"\n    js_data = response_js.json()\n    assert \"token\" in js_data and js_data[\"token\"], \"Jobseeker JWT token missing\"\n    # Extract token for role-based access test\n    js_token = js_data[\"token\"]\n\n    # 2. Recruiter login\n    response_rc = requests.post(\n        f\"{BASE_URL}/api/auth/login\",\n        json={\n            \"email\": recruiter_credentials[\"email\"],\n            \"password\": recruiter_credentials[\"password\"]\n        },\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    assert response_rc.status_code == 200, \"Recruiter login failed\"\n    rc_data = response_rc.json()\n    assert \"token\" in rc_data and rc_data[\"token\"], \"Recruiter JWT token missing\"\n    rc_token = rc_data[\"token\"]\n\n    # 3. Admin login with 2FA\n    response_ad = requests.post(\n        f\"{BASE_URL}/api/admin/auth/login\",\n        json={\n            \"email\": admin_credentials[\"email\"],\n            \"password\": admin_credentials[\"password\"],\n            \"twoFactorCode\": admin_credentials[\"twoFactorCode\"]\n        },\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    # Admin login may support 2FA optionally:\n    # Accept 200 for success, 401 for invalid 2FA or credentials\n    # We test a valid 2FA scenario here, so expect 200\n    assert response_ad.status_code == 200, f\"Admin login with 2FA failed: {response_ad.text}\"\n    ad_data = response_ad.json()\n    assert \"token\" in ad_data and ad_data[\"token\"], \"Admin JWT token missing\"\n    ad_token = ad_data[\"token\"]\n\n    # 4. Verify role-based access control enforcement\n    # Test Jobseeker access to recruiter-only endpoint:\n    # Assuming recruiter profile GET requires recruiter role\n    headers_js_auth = {\"Authorization\": f\"Bearer {js_token}\"}\n    recruiter_profile_response = requests.get(\n        f\"{BASE_URL}/api/recruiter/profile\",\n        headers=headers_js_auth,\n        timeout=TIMEOUT\n    )\n    # Expect 403 Forbidden or 401 Unauthorized, since jobseeker should not access recruiter route\n    assert recruiter_profile_response.status_code in {401, 403}, (\n        \"Jobseeker should not access recruiter-only endpoint\"\n    )\n\n    # Test Recruiter access to admin endpoint - we do not have explicit admin endpoints from PRD,\n    # but let's assume /api/admin/dashboard or any protected path is admin-only.\n    # Since no explicit admin API endpoints given for test, we test admin/auth/login only.\n    # We skip unauthorized check for recruiter to admin endpoint as not specified.\n\n    # 5. Test admin 2FA enforcement - invalid 2FA code causes login failure\n    invalid_2fa_response = requests.post(\n        f\"{BASE_URL}/api/admin/auth/login\",\n        json={\n            \"email\": admin_credentials[\"email\"],\n            \"password\": admin_credentials[\"password\"],\n            \"twoFactorCode\": \"000000\"  # Invalid 2FA\n        },\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    assert invalid_2fa_response.status_code == 401, \"Admin login should fail with invalid 2FA\"\n\n    # 6. Test admin login without 2FA (optional)\n    # Try login with no twoFactorCode field to verify optional 2FA\n    no_2fa_response = requests.post(\n        f\"{BASE_URL}/api/admin/auth/login\",\n        json={\n            \"email\": admin_credentials[\"email\"],\n            \"password\": admin_credentials[\"password\"]\n        },\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    # May pass or fail depending on 2FA configuration; accept either 200 or 401\n    assert no_2fa_response.status_code in {200, 401}, (\n        \"Admin login without 2FA should respond with 200 or 401\"\n    )\n    if no_2fa_response.status_code == 200:\n        no_2fa_data = no_2fa_response.json()\n        assert \"token\" in no_2fa_data and no_2fa_data[\"token\"], \"Token missing on admin login without 2FA\"\n\n    # 7. Test login failure for wrong credentials for jobseeker\n    login_fail_response = requests.post(\n        f\"{BASE_URL}/api/auth/login\",\n        json={\n            \"email\": jobseeker_credentials[\"email\"],\n            \"password\": \"WrongPassword!\"\n        },\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    assert login_fail_response.status_code == 401, \"Login should fail with wrong credentials\"\n\n    # 8. Test login failure for wrong credentials for admin\n    login_fail_admin_response = requests.post(\n        f\"{BASE_URL}/api/admin/auth/login\",\n        json={\n            \"email\": admin_credentials[\"email\"],\n            \"password\": \"WrongAdminPass!\",\n            \"twoFactorCode\": admin_credentials[\"twoFactorCode\"]\n        },\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    assert login_fail_admin_response.status_code == 401, \"Admin login should fail with wrong credentials\"\n\ntest_authentication_with_role_based_access_and_2fa()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 155, in <module>\n  File \"<string>\", line 39, in test_authentication_with_role_based_access_and_2fa\nAssertionError: Jobseeker login failed\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-09T13:27:22.672Z",
    "modified": "2025-10-09T13:31:34.581Z"
  },
  {
    "projectId": "5c818b43-5e36-4bc2-a2fa-87f6e50dd335",
    "testId": "d906ffe9-d237-4135-95be-ee94c0f7a344",
    "userId": "047854f8-5091-70b6-a288-9cd9577df3b3",
    "title": "TC005-test_view_tracking_and_unique_visitor_metrics",
    "description": "Verify that the view tracking endpoints correctly record unique views of profiles and jobs, enforce rate limiting to prevent spamming, and provide accurate daily unique visitor counts.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_view_tracking_and_unique_visitor_metrics():\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Helper function to track a view for given entity and id\n    def track_view(entity, entity_id, viewer_id=None, session_id=None):\n        payload = {\n            \"entity\": entity,\n            \"id\": entity_id\n        }\n        if viewer_id:\n            payload[\"viewerId\"] = viewer_id\n        if session_id:\n            payload[\"sessionId\"] = session_id\n        return requests.post(f\"{BASE_URL}/api/views/track\", json=payload, headers=headers, timeout=TIMEOUT)\n\n    # Helper function to get unique view count for an entity\n    def get_view_count(entity, entity_id):\n        return requests.get(f\"{BASE_URL}/api/views/{entity}/{entity_id}\", headers=headers, timeout=TIMEOUT)\n\n    # Step 1: Create test profile and job entities to simulate views (simulate entities)\n    # Since no explicit API for creating profiles/jobs is described, \n    # we will simulate with dummy ids.\n    test_profile_id = \"test-profile-12345\"\n    test_job_id = \"test-job-54321\"\n\n    # Define viewer and session IDs to simulate unique viewers\n    viewer_ids = [\"viewer1\", \"viewer2\", \"viewer3\"]\n    session_ids = [\"session1\", \"session2\", \"session3\"]\n\n    # Step 2: Track unique views on profile and job by different viewers/sessions\n    responses = []\n    for v_id, s_id in zip(viewer_ids, session_ids):\n        resp_profile = track_view(\"profile\", test_profile_id, viewer_id=v_id, session_id=s_id)\n        resp_job = track_view(\"job\", test_job_id, viewer_id=v_id, session_id=s_id)\n        responses.extend([resp_profile, resp_job])\n\n    # Check all track view responses are 200\n    for resp in responses:\n        assert resp.status_code == 200, f\"Expected 200 OK tracking view, got {resp.status_code}\"\n\n    # Step 3: Attempt to spam views by sending multiple views from same viewer/session quickly\n    spam_responses = []\n    for _ in range(5):\n        resp_spam_profile = track_view(\"profile\", test_profile_id, viewer_id=\"viewer1\", session_id=\"session1\")\n        resp_spam_job = track_view(\"job\", test_job_id, viewer_id=\"viewer1\", session_id=\"session1\")\n        spam_responses.extend([resp_spam_profile, resp_spam_job])\n        time.sleep(0.1)  # short sleep between requests\n\n    # Step 4: Retrieve unique view counts for profile and job\n    view_count_profile_resp = get_view_count(\"profile\", test_profile_id)\n    view_count_job_resp = get_view_count(\"job\", test_job_id)\n\n    assert view_count_profile_resp.status_code == 200, f\"Failed to get view count for profile: {view_count_profile_resp.status_code}\"\n    assert view_count_job_resp.status_code == 200, f\"Failed to get view count for job: {view_count_job_resp.status_code}\"\n\n    profile_count_data = view_count_profile_resp.json()\n    job_count_data = view_count_job_resp.json()\n\n    # The counts should match number of unique viewers (3) if rate limiting prevents counting repeated views\n    # Assuming response JSON has {\"uniqueViews\": int} or similar - validate existence and type\n    assert isinstance(profile_count_data, dict), \"Profile count response JSON is not a dict\"\n    assert isinstance(job_count_data, dict), \"Job count response JSON is not a dict\"\n\n    assert \"uniqueViews\" in profile_count_data, \"Profile count response missing 'uniqueViews'\"\n    assert \"uniqueViews\" in job_count_data, \"Job count response missing 'uniqueViews'\"\n\n    profile_unique_views = profile_count_data[\"uniqueViews\"]\n    job_unique_views = job_count_data[\"uniqueViews\"]\n\n    assert profile_unique_views == len(viewer_ids), f\"Profile unique views expected {len(viewer_ids)}, got {profile_unique_views}\"\n    assert job_unique_views == len(viewer_ids), f\"Job unique views expected {len(viewer_ids)}, got {job_unique_views}\"\n\n    # Step 5: Verify that spamming did not increase the count\n    # Track count again, expect same counts\n    repeated_profile_count_resp = get_view_count(\"profile\", test_profile_id)\n    repeated_job_count_resp = get_view_count(\"job\", test_job_id)\n    repeated_profile_count = repeated_profile_count_resp.json().get(\"uniqueViews\")\n    repeated_job_count = repeated_job_count_resp.json().get(\"uniqueViews\")\n\n    assert repeated_profile_count == profile_unique_views, \"Spam views increased profile unique views unexpectedly\"\n    assert repeated_job_count == job_unique_views, \"Spam views increased job unique views unexpectedly\"\n\ntest_view_tracking_and_unique_visitor_metrics()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 91, in <module>\n  File \"<string>\", line 47, in test_view_tracking_and_unique_visitor_metrics\nAssertionError: Expected 200 OK tracking view, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-09T13:27:22.677Z",
    "modified": "2025-10-09T13:31:34.584Z"
  },
  {
    "projectId": "5c818b43-5e36-4bc2-a2fa-87f6e50dd335",
    "testId": "0156e9cc-fc77-4eb4-b9e8-9934a05f53aa",
    "userId": "047854f8-5091-70b6-a288-9cd9577df3b3",
    "title": "TC006-test_recruiter_profile_read_and_update",
    "description": "Check that recruiters can retrieve their profile information and update it successfully, with proper handling of not found errors.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\n# Placeholder credentials for recruiter login (should be replaced with valid ones)\nRECRUITER_LOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nRECRUITER_PROFILE_URL = f\"{BASE_URL}/api/recruiter/profile\"\n\n# Sample recruiter credentials - MUST be valid in the test environment\nRECRUITER_CREDENTIALS = {\n    \"email\": \"testrecruiter@example.com\",\n    \"password\": \"TestPassword123!\"\n}\n\n# Sample data to create a new recruiter profile if needed\nNEW_RECRUITER_PROFILE = {\n    \"company_name\": \"Test Company Inc\",\n    \"contact_name\": \"Test Recruiter\",\n    \"phone\": \"+1234567890\",\n    \"website\": \"https://testcompany.example.com\",\n    \"bio\": \"Recruiter for testing purposes\"\n}\n\n# Sample updates for recruiter profile\nUPDATED_PROFILE_DATA = {\n    \"company_name\": \"Updated Company LLC\",\n    \"contact_name\": \"Updated Recruiter\",\n    \"phone\": \"+0987654321\",\n    \"website\": \"https://updatedcompany.example.com\",\n    \"bio\": \"Updated recruiter profile for testing update endpoint\"\n}\n\n\ndef test_recruiter_profile_read_and_update():\n    # First, log in to get an authentication token\n    try:\n        login_resp = requests.post(\n            RECRUITER_LOGIN_URL,\n            json=RECRUITER_CREDENTIALS,\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed with status_code {login_resp.status_code}\"\n        token = login_resp.json().get(\"token\")\n        assert token, \"No token returned in login response\"\n    except Exception as e:\n        raise AssertionError(f\"Recruiter login failed: {e}\")\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Attempt to GET current recruiter profile\n    try:\n        profile_resp = requests.get(RECRUITER_PROFILE_URL, headers=headers, timeout=TIMEOUT)\n    except Exception as e:\n        raise AssertionError(f\"GET recruiter profile request failed: {e}\")\n\n    if profile_resp.status_code == 404:\n        # Profile not found - create a new profile using PUT as per endpoint (assuming PUT creates if not exists)\n        try:\n            create_resp = requests.put(RECRUITER_PROFILE_URL, headers=headers, json=NEW_RECRUITER_PROFILE, timeout=TIMEOUT)\n            assert create_resp.status_code == 200, f\"Profile creation failed with status code {create_resp.status_code}\"\n        except Exception as e:\n            raise AssertionError(f\"Profile creation failed: {e}\")\n\n        # Retry getting the profile after creation\n        try:\n            profile_resp = requests.get(RECRUITER_PROFILE_URL, headers=headers, timeout=TIMEOUT)\n            assert profile_resp.status_code == 200, \"Profile should exist after creation but GET failed\"\n            profile_data = profile_resp.json()\n            # Basic assertions on profile content type (dict)\n            assert isinstance(profile_data, dict), \"Profile data is not a dictionary after creation\"\n        except Exception as e:\n            raise AssertionError(f\"GET recruiter profile after creation failed: {e}\")\n\n    elif profile_resp.status_code == 200:\n        # Profile found, parse data\n        profile_data = profile_resp.json()\n        assert isinstance(profile_data, dict), \"Returned profile data is not a dictionary\"\n    else:\n        raise AssertionError(f\"Unexpected status code for GET recruiter profile: {profile_resp.status_code}\")\n\n    # Try updating the recruiter profile with new data\n    try:\n        update_resp = requests.put(RECRUITER_PROFILE_URL, headers=headers, json=UPDATED_PROFILE_DATA, timeout=TIMEOUT)\n        assert update_resp.status_code == 200, f\"Profile update failed with status code {update_resp.status_code}\"\n        updated_data = update_resp.json()\n        # Validate updated fields returned match input where applicable\n        for key, value in UPDATED_PROFILE_DATA.items():\n            assert updated_data.get(key) == value, f\"Updated profile field '{key}' does not match update data\"\n    except Exception as e:\n        raise AssertionError(f\"Updating recruiter profile failed: {e}\")\n\n    # Test error handling by simulating a GET to a wrong/non-existent recruiter's profile endpoint\n    # Since the endpoint is fixed, simulate by removing token or using corrupted token to get 404 or 401\n    try:\n        # Without auth headers: expecting 404 or 401 unauthorized\n        error_resp = requests.get(RECRUITER_PROFILE_URL, timeout=TIMEOUT)\n        assert error_resp.status_code in (401, 404), f\"Expected 401 or 404 without auth, got {error_resp.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Error case (unauthenticated GET) failed: {e}\")\n\n    # Test error handling on update with invalid data (e.g. empty JSON)\n    try:\n        invalid_update_resp = requests.put(RECRUITER_PROFILE_URL, headers=headers, json={}, timeout=TIMEOUT)\n        # Expecting 400 or 404 if empty body not allowed or profile not found\n        assert invalid_update_resp.status_code in (400, 404), \"Expected 400 or 404 for invalid update data\"\n    except Exception as e:\n        raise AssertionError(f\"Invalid update data handling failed: {e}\")\n\n\ntest_recruiter_profile_read_and_update()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 43, in test_recruiter_profile_read_and_update\nAssertionError: Login failed with status_code 401\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 114, in <module>\n  File \"<string>\", line 47, in test_recruiter_profile_read_and_update\nAssertionError: Recruiter login failed: Login failed with status_code 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-09T13:27:22.683Z",
    "modified": "2025-10-09T13:29:10.777Z"
  },
  {
    "projectId": "5c818b43-5e36-4bc2-a2fa-87f6e50dd335",
    "testId": "8e28ae4f-406c-4912-a68f-4317ea2d985f",
    "userId": "047854f8-5091-70b6-a288-9cd9577df3b3",
    "title": "TC007-test_profile_view_tracking_and_count_retrieval",
    "description": "Ensure that the profile view tracking endpoints correctly log when a user views another user's profile and accurately return the unique viewer count for a specified userId.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\n# Helper function to login as a job seeker user to get JWT token\n# Using placeholder credentials because the PRD requires auth but does not specify test user creation\n\ndef get_auth_token():\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    login_payload = {\n        \"email\": \"jobseeker@example.com\",\n        \"password\": \"password123\"\n    }\n    headers = {\"Content-Type\": \"application/json\"}\n    response = requests.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n    assert response.status_code == 200, f\"Login failed with status {response.status_code}\"\n    data = response.json()\n    assert \"token\" in data, \"Login response missing 'token'\"\n    return data[\"token\"]\n\n\ndef test_profile_view_tracking_and_count_retrieval():\n    token = get_auth_token()\n\n    # Setup: Create two dummy userIds for viewer and profile owner\n    profile_owner_id = str(uuid.uuid4())\n    viewer_id = str(uuid.uuid4())\n    \n    track_url = f\"{BASE_URL}/api/profile/view\"\n    count_url = f\"{BASE_URL}/api/profile/views/{profile_owner_id}\"\n\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    payload = {\n        \"viewerUserId\": viewer_id,\n        \"viewedUserId\": profile_owner_id\n    }\n\n    # Using try-finally in case of any future resource cleanup\n    try:\n        # Track the profile view of viewerUserId viewing viewedUserId\n        track_response = requests.post(track_url, json=payload, headers=headers, timeout=TIMEOUT)\n        assert track_response.status_code == 200, f\"Expected 200 OK, got {track_response.status_code}\"\n        # The response could be a message or count, just verify presence and type\n        assert track_response.json() is not None\n\n        # Track the same viewer again, should not increase unique count (idempotent or ignored)\n        track_response_repeat = requests.post(track_url, json=payload, headers=headers, timeout=TIMEOUT)\n        assert track_response_repeat.status_code == 200\n\n        # Another viewer views the same profile to verify count update\n        another_viewer_id = str(uuid.uuid4())\n        payload_another_view = {\n            \"viewerUserId\": another_viewer_id,\n            \"viewedUserId\": profile_owner_id\n        }\n        track_response_another = requests.post(track_url, json=payload_another_view, headers=headers, timeout=TIMEOUT)\n        assert track_response_another.status_code == 200\n\n        # Retrieve the unique viewer count for the profile_owner_id\n        count_response = requests.get(count_url, headers=headers, timeout=TIMEOUT)\n        assert count_response.status_code == 200, f\"Expected 200 OK, got {count_response.status_code}\"\n\n        count_data = count_response.json()\n        # The count response should include the count, assuming a JSON object with \"count\" key or a raw integer\n        # Accept either {\"count\": int} or just an integer in response JSON\n        if isinstance(count_data, dict):\n            assert \"count\" in count_data, \"Response JSON missing 'count' key\"\n            count_value = count_data[\"count\"]\n        elif isinstance(count_data, int):\n            count_value = count_data\n        else:\n            raise AssertionError(\"Unexpected format for view count response\")\n\n        # The count must be at least 2 due to two unique viewers tracked above\n        assert isinstance(count_value, int) and count_value >= 2, f\"Expected count >= 2, got {count_value}\"\n\n    finally:\n        # No specific cleanup endpoint documented for profile views; nothing to delete\n        pass\n\n\ntest_profile_view_tracking_and_count_retrieval()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 88, in <module>\n  File \"<string>\", line 25, in test_profile_view_tracking_and_count_retrieval\n  File \"<string>\", line 18, in get_auth_token\nAssertionError: Login failed with status 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-09T13:27:22.689Z",
    "modified": "2025-10-09T13:30:30.948Z"
  },
  {
    "projectId": "5c818b43-5e36-4bc2-a2fa-87f6e50dd335",
    "testId": "7e206cc5-5090-4087-958f-3b8bf828d2f4",
    "userId": "047854f8-5091-70b6-a288-9cd9577df3b3",
    "title": "TC008-test_job_application_and_interview_scheduling",
    "description": "Validate that job seekers can apply for jobs, track application statuses, and schedule interviews, with all data correctly persisted and retrievable via the API.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_job_application_and_interview_scheduling():\n    # Authenticate as a job seeker to get a JWT token\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    jobseeker_credentials = {\n        \"email\": \"testjobseeker@example.com\",\n        \"password\": \"TestPassword123!\"\n    }\n    try:\n        login_resp = requests.post(login_url, json=jobseeker_credentials, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        token = login_resp.json().get(\"token\")\n        assert token, \"No token received on login\"\n    except Exception as e:\n        raise AssertionError(f\"Authentication step failed: {e}\")\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    job_id = None\n    application_id = None\n    interview_id = None\n\n    try:\n        # Step 1: Retrieve list of jobs to apply for\n        jobs_resp = requests.get(f\"{BASE_URL}/api/jobseeker/jobs\", headers=headers, timeout=TIMEOUT)\n        assert jobs_resp.status_code == 200, f\"Failed to get jobs: {jobs_resp.text}\"\n        jobs = jobs_resp.json()\n        assert isinstance(jobs, list) and len(jobs) > 0, \"Jobs list is empty\"\n\n        # Pick the first job to apply\n        job_id = jobs[0].get(\"id\")\n        assert job_id, \"Job id missing in jobs list\"\n\n        # Step 2: Apply for the selected job\n        apply_payload = {\n            \"jobId\": job_id,\n            \"coverLetter\": \"I am excited to apply for this position and bring my skills to your company.\"\n        }\n        apply_resp = requests.post(f\"{BASE_URL}/api/jobseeker/applications\", headers=headers, json=apply_payload, timeout=TIMEOUT)\n        assert apply_resp.status_code == 201, f\"Application creation failed: {apply_resp.text}\"\n        application = apply_resp.json()\n        application_id = application.get(\"id\")\n        assert application_id, \"Application ID not returned\"\n\n        # Step 3: Retrieve the application and verify status and data\n        get_app_resp = requests.get(f\"{BASE_URL}/api/jobseeker/applications/{application_id}\", headers=headers, timeout=TIMEOUT)\n        assert get_app_resp.status_code == 200, f\"Failed to retrieve application: {get_app_resp.text}\"\n        application_data = get_app_resp.json()\n        assert application_data.get(\"jobId\") == job_id, \"Application jobId mismatch\"\n        assert application_data.get(\"status\") in [\"submitted\", \"under_review\"], \"Unexpected application status\"\n\n        # Step 4: Schedule an interview for the application\n        interview_payload = {\n            \"applicationId\": application_id,\n            \"scheduledTime\": \"2030-12-01T15:00:00Z\",\n            \"location\": \"Zoom Meeting\",\n            \"notes\": \"Initial technical interview\"\n        }\n        schedule_resp = requests.post(f\"{BASE_URL}/api/jobseeker/interviews\", headers=headers, json=interview_payload, timeout=TIMEOUT)\n        assert schedule_resp.status_code == 201, f\"Interview scheduling failed: {schedule_resp.text}\"\n        interview = schedule_resp.json()\n        interview_id = interview.get(\"id\")\n        assert interview_id, \"Interview ID not returned\"\n\n        # Step 5: Retrieve the scheduled interview and verify details\n        get_interview_resp = requests.get(f\"{BASE_URL}/api/jobseeker/interviews/{interview_id}\", headers=headers, timeout=TIMEOUT)\n        assert get_interview_resp.status_code == 200, f\"Failed to retrieve interview: {get_interview_resp.text}\"\n        interview_data = get_interview_resp.json()\n        assert interview_data.get(\"applicationId\") == application_id, \"Interview applicationId mismatch\"\n        assert interview_data.get(\"scheduledTime\") == \"2030-12-01T15:00:00Z\", \"Interview scheduledTime mismatch\"\n        assert interview_data.get(\"location\") == \"Zoom Meeting\", \"Interview location mismatch\"\n        assert interview_data.get(\"notes\") == \"Initial technical interview\", \"Interview notes mismatch\"\n\n        # Step 6: List all applications to check newly created application is listed\n        list_apps_resp = requests.get(f\"{BASE_URL}/api/jobseeker/applications\", headers=headers, timeout=TIMEOUT)\n        assert list_apps_resp.status_code == 200, f\"Failed to list applications: {list_apps_resp.text}\"\n        applications = list_apps_resp.json()\n        assert any(app.get(\"id\") == application_id for app in applications), \"New application not found in applications list\"\n\n        # Step 7: List all interviews to check newly created interview is listed\n        list_interviews_resp = requests.get(f\"{BASE_URL}/api/jobseeker/interviews\", headers=headers, timeout=TIMEOUT)\n        assert list_interviews_resp.status_code == 200, f\"Failed to list interviews: {list_interviews_resp.text}\"\n        interviews = list_interviews_resp.json()\n        assert any(itv.get(\"id\") == interview_id for itv in interviews), \"New interview not found in interviews list\"\n\n    finally:\n        # Cleanup: Delete the created interview, application if exists\n        if interview_id:\n            try:\n                del_itv_resp = requests.delete(f\"{BASE_URL}/api/jobseeker/interviews/{interview_id}\", headers=headers, timeout=TIMEOUT)\n                assert del_itv_resp.status_code in [200,204], f\"Failed to delete interview: {del_itv_resp.text}\"\n            except Exception:\n                pass\n        if application_id:\n            try:\n                del_app_resp = requests.delete(f\"{BASE_URL}/api/jobseeker/applications/{application_id}\", headers=headers, timeout=TIMEOUT)\n                assert del_app_resp.status_code in [200,204], f\"Failed to delete application: {del_app_resp.text}\"\n            except Exception:\n                pass\n\n\ntest_job_application_and_interview_scheduling()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 15, in test_job_application_and_interview_scheduling\nAssertionError: Login failed: {\"success\":false,\"error\":\"Invalid email or password\"}\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 109, in <module>\n  File \"<string>\", line 19, in test_job_application_and_interview_scheduling\nAssertionError: Authentication step failed: Login failed: {\"success\":false,\"error\":\"Invalid email or password\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-09T13:27:22.696Z",
    "modified": "2025-10-09T13:29:23.166Z"
  },
  {
    "projectId": "5c818b43-5e36-4bc2-a2fa-87f6e50dd335",
    "testId": "5bfb8fa9-2cc8-4b87-84df-e488e43785a9",
    "userId": "047854f8-5091-70b6-a288-9cd9577df3b3",
    "title": "TC009-test_recruiter_email_communication_with_candidates",
    "description": "Test that recruiters can send emails to candidates through the API, ensuring email content is delivered and logged appropriately.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_recruiter_email_communication_with_candidates():\n    # Assumptions:\n    # - There is an authentication endpoint at /api/auth/login for recruiters\n    # - Recruiters send emails via POST /api/recruiter/email with payload containing candidate email and message\n    # - To test sending email, a candidate user needs to exist or be created\n    # - The API requires Authorization header with Bearer token for authenticated recruiter calls\n    # - There is an endpoint to create a candidate (job seeker) at /api/jobseeker/register\n    # - There is an endpoint to delete the candidate at /api/jobseeker/{id} (assuming DELETE)\n    # - No direct schema details for candidate creation or email sending, so using reasonable fields\n    # - Email sending endpoint: POST /api/recruiter/email (as logical guess)\n    # - Validate that the response status is success and response body contains confirmation/log info\n\n    recruiter_credentials = {\n        \"email\": \"recruiter@example.com\",\n        \"password\": \"RecruiterPass123\"\n    }\n\n    candidate_data = {\n        \"email\": f\"candidate_{uuid.uuid4().hex[:8]}@example.com\",\n        \"password\": \"CandidatePass123\",\n        \"role\": \"jobseeker\",\n        \"firstName\": \"Test\",\n        \"lastName\": \"Candidate\"\n    }\n\n    email_payload = {\n        \"to\": None,  # to be set with candidate email\n        \"subject\": \"Job Opportunity\",\n        \"body\": \"Dear candidate, we are interested in your profile. Please respond.\"\n    }\n\n    try:\n        # 1. Login recruiter to obtain JWT token\n        login_resp = requests.post(\n            f\"{BASE_URL}/api/auth/login\",\n            json=recruiter_credentials,\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Recruiter login failed: {login_resp.text}\"\n        recruiter_token = login_resp.json().get(\"token\")\n        assert recruiter_token, \"No token returned on recruiter login\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {recruiter_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # 2. Create a candidate (job seeker) to send email to\n        create_candidate_resp = requests.post(\n            f\"{BASE_URL}/api/jobseeker/register\",\n            json=candidate_data,\n            timeout=TIMEOUT\n        )\n        assert create_candidate_resp.status_code == 201, f\"Candidate creation failed: {create_candidate_resp.text}\"\n        created_candidate = create_candidate_resp.json()\n        candidate_id = created_candidate.get(\"id\") or created_candidate.get(\"userId\")\n        candidate_email = created_candidate.get(\"email\") or candidate_data[\"email\"]\n        assert candidate_id is not None, \"Candidate ID missing in creation response\"\n        assert candidate_email is not None, \"Candidate email missing in creation response\"\n\n        # 3. Send email from recruiter to candidate\n        email_payload[\"to\"] = candidate_email\n\n        send_email_resp = requests.post(\n            f\"{BASE_URL}/api/recruiter/email\",\n            headers=headers,\n            json=email_payload,\n            timeout=TIMEOUT\n        )\n\n        # Validate 200 or 202 acceptance for email send\n        assert send_email_resp.status_code in (200, 202), f\"Email send failed: {send_email_resp.text}\"\n\n        email_response_data = send_email_resp.json()\n        # Validate presence of any confirmation/log keys\n        assert \"message\" in email_response_data or \"status\" in email_response_data, \"No confirmation/log in email response\"\n\n    finally:\n        # Cleanup: delete created candidate if exists and token is available\n        try:\n            if 'candidate_id' in locals():\n                # Assume recruiter token can't delete candidate; try unauth or no auth for user delete\n                # Best effort delete - might require admin token or candidate login in real scenario\n                requests.delete(\n                    f\"{BASE_URL}/api/jobseeker/{candidate_id}\",\n                    timeout=TIMEOUT\n                )\n        except Exception:\n            pass\n\ntest_recruiter_email_communication_with_candidates()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 97, in <module>\n  File \"<string>\", line 45, in test_recruiter_email_communication_with_candidates\nAssertionError: Recruiter login failed: {\"success\":false,\"error\":\"Invalid email or password\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-09T13:27:22.703Z",
    "modified": "2025-10-09T13:30:00.031Z"
  },
  {
    "projectId": "5c818b43-5e36-4bc2-a2fa-87f6e50dd335",
    "testId": "73db4d7c-4d77-43a8-b941-e0463a3bd261",
    "userId": "047854f8-5091-70b6-a288-9cd9577df3b3",
    "title": "TC010-test_admin_system_logs_and_analytics_access",
    "description": "Verify that admins can access system logs and analytics dashboards with correct data aggregation and filtering capabilities.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nADMIN_LOGIN_ENDPOINT = f\"{BASE_URL}/api/admin/auth/login\"\nSYSTEM_LOGS_ENDPOINT = f\"{BASE_URL}/api/admin/logs\"\nANALYTICS_DASHBOARD_ENDPOINT = f\"{BASE_URL}/api/admin/analytics\"\n\n# Admin credentials for testing (should be replaced with valid test credentials or from secure config)\nADMIN_CREDENTIALS = {\n    \"email\": \"admin_test\",\n    \"password\": \"admin_test_password\",\n    # Assuming 2FA is optional and not required here. If required, include \"twoFactorCode\": \"123456\"\n}\n\ndef test_admin_system_logs_and_analytics_access():\n    # Login as admin to get JWT token\n    try:\n        login_resp = requests.post(\n            ADMIN_LOGIN_ENDPOINT,\n            json=ADMIN_CREDENTIALS,\n            timeout=30\n        )\n        assert login_resp.status_code == 200, f\"Admin login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        token = login_data.get(\"token\")\n        assert token, \"No token received on admin login\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {token}\"\n        }\n\n        # Access system logs with filtering and pagination parameters for example\n        params_logs = {\n            \"page\": 1,\n            \"limit\": 20,\n            \"filter\": \"error\",  # example filter to get only error logs\n            \"sort\": \"timestamp_desc\"\n        }\n        logs_resp = requests.get(\n            SYSTEM_LOGS_ENDPOINT,\n            headers=headers,\n            params=params_logs,\n            timeout=30\n        )\n        assert logs_resp.status_code == 200, f\"Failed to access system logs: {logs_resp.text}\"\n        logs_data = logs_resp.json()\n        assert \"logs\" in logs_data and isinstance(logs_data[\"logs\"], list), \"Logs data missing or not a list\"\n        # Verify some expected keys in a log entry\n        if logs_data[\"logs\"]:\n            log_entry = logs_data[\"logs\"][0]\n            for key in [\"timestamp\", \"level\", \"message\"]:\n                assert key in log_entry, f\"Log entry missing key: {key}\"\n\n        # Access analytics dashboard with aggregation and filters\n        params_analytics = {\n            \"startDate\": \"2025-01-01\",\n            \"endDate\": \"2025-12-31\",\n            \"aggregation\": \"monthly\",\n            \"metrics\": \"userActivity,pageViews\",\n            \"filter\": \"activeUsers>100\"\n        }\n        analytics_resp = requests.get(\n            ANALYTICS_DASHBOARD_ENDPOINT,\n            headers=headers,\n            params=params_analytics,\n            timeout=30\n        )\n        assert analytics_resp.status_code == 200, f\"Failed to access analytics dashboard: {analytics_resp.text}\"\n        analytics_data = analytics_resp.json()\n        # Validate expected structure of analytics data (this may vary, checking for keys)\n        assert \"aggregatedData\" in analytics_data, \"Analytics dashboard missing 'aggregatedData'\"\n        assert isinstance(analytics_data[\"aggregatedData\"], list), \"'aggregatedData' should be a list\"\n\n        if analytics_data[\"aggregatedData\"]:\n            agg_entry = analytics_data[\"aggregatedData\"][0]\n            # Check for typical keys: date, metrics dictionary\n            assert \"date\" in agg_entry, \"Aggregated data entry missing 'date'\"\n            assert \"metrics\" in agg_entry and isinstance(agg_entry[\"metrics\"], dict), \"Aggregated data entry missing 'metrics' dict\"\n\n    except requests.RequestException as e:\n        raise AssertionError(f\"HTTP request failed: {e}\")\n\ntest_admin_system_logs_and_analytics_access()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 83, in <module>\n  File \"<string>\", line 23, in test_admin_system_logs_and_analytics_access\nAssertionError: Admin login failed: {\"success\":false,\"error\":\"Invalid email or password\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-09T13:27:22.709Z",
    "modified": "2025-10-09T13:31:23.148Z"
  }
]
